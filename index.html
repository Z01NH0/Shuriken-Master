<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shuriken Master </title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #000;
            color: white;
        }
        canvas {
            display: block;
            border: 3px solid red;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
        }
        #health-bar {
            width: 200px;
            height: 20px;
            background-color: #333;
            border: 2px solid #555;
            margin-bottom: 5px;
        }
        #health-fill {
            height: 100%;
            width: 100%;
            background-color: #ff0000;
            transition: width 0.3s;
        }
        #xp-bar {
            width: 200px;
            height: 10px;
            background-color: #333;
            border: 2px solid #555;
            margin-bottom: 5px;
        }
        #xp-fill {
            height: 100%;
            width: 0%;
            background-color: #00ff00;
            transition: width 0.3s;
        }
        #wave-info {
            font-size: 18px;
            margin-bottom: 5px;
        }
        #score {
            font-size: 18px;
            margin-bottom: 5px;
        }
        #level {
            font-size: 18px;
            margin-bottom: 5px;
        }
        #powerups {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: none;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            pointer-events: auto;
        }
        .powerup-option {
            padding: 8px;
            margin: 5px;
            background-color: #333;
            border: 1px solid #555;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .powerup-option:hover {
            background-color: #555;
        }
        #boss-health {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px;
            height: 30px;
            background-color: #333;
            border: 3px solid #ff0000;
            display: none;
        }
        #boss-health-fill {
            height: 100%;
            width: 100%;
            background-color: #ff0000;
            transition: width 0.3s;
        }
        #boss-name {
            position: absolute;
            top: -20px;
            left: 0;
            font-size: 16px;
            color: #fff;
            text-shadow: 0 0 5px #ff0000;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #restart-btn {
            padding: 10px 20px;
            background-color: #ff3333;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
        }
        #restart-btn:hover {
            background-color: #ff5555;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        #powerup-buttons {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
        }
        .powerup-btn {
            width: 50px;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff00;
            color: white;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .powerup-btn:hover {
            background-color: rgba(0, 255, 0, 0.2);
        }
        .boss-image {
            position: absolute;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="health-bar">
            <div id="health-fill"></div>
        </div>
        <div id="xp-bar">
            <div id="xp-fill"></div>
        </div>
        <div id="wave-info">Onda: 1</div>
        <div id="score">Pontuação: 0</div>
        <div id="level">Nível: 1</div>
    </div>
    
    <div id="boss-health">
        <div id="boss-name"></div>
        <div id="boss-health-fill"></div>
    </div>
    
    <div id="powerups">
        <h3>Escolha um Poder!</h3>
        <div id="powerup-options"></div>
    </div>
    
    <div id="powerup-buttons">
        <div class="powerup-btn" id="powerup-btn-1">1</div>
        <div class="powerup-btn" id="powerup-btn-2">2</div>
        <div class="powerup-btn" id="powerup-btn-3">3</div>
    </div>
    
    <div id="game-over">
        <h2>FIM DE JOGO</h2>
        <p id="final-score">Pontuação: 0</p>
        <p id="final-wave">Onda: 0</p>
        <p id="final-level">Nível: 0</p>
        <button id="restart-btn">Jogar Novamente</button>
    </div>
    
    <div id="controls">
        <p>WASD: Mover</p>
        <p>Mouse: Mirar</p>
        <p>Clique Esquerdo: Lançar Shuriken</p>
        <p>1/2/3: Selecionar Poder</p>
    </div>

    <script>
        const config = {
            playerSpeed: 4,
            playerHealth: 135,
            shurikenSpeed: 10,
            shurikenCooldown: 450,
            enemySpawnRate: 2000,
            waveDuration: 40000,
            xpRequirements: [250, 500, 850, 1300, 1650, 2100, 2700, 3250, 3800, 4550, 5000]
        };

        const gameState = {
            canvas: null,
            ctx: null,
            lastTime: 0,
            keys: {},
            mouse: { x: 0, y: 0, isDown: false },
            player: null,
            shurikens: [],
            enemies: [],
            bosses: [],
            particles: [],
            explosionHitboxes: [],
            wave: 1,
            waveTimer: 0,
            score: 0,
            xp: 0,
            xpToLevel: config.xpRequirements[0],
            level: 1,
            gameOver: false,
            spawnTimer: 0,
            shurikenTimer: 0,
            activePowerups: [],
            bossActive: false,
            bossSpawned: false,
            currentPowerups: [],
            doubleShotChance: 0,
            atomicShurikenChance: 0,
            shocked: false,
            shockTimer: 0,
            shockDuration: 3000,
            miniDragonTimer: 0,
            omegaBossActive: false,
            damageMultiplier: 1,
            furyStacks: 0,
            lastMeditationHeal: 0,
            lastStandStillTime: 0,
            isStandingStill: false,
            dragonFuryActive: false,
            dragonFuryEndTime: 0,
            lastOmniSlashTime: 0,
            bossImages: {}
        };

        // Carregar imagens dos bosses (substitua pelas URLs reais das imagens)
        function loadBossImages() {
            gameState.bossImages = {
                'dragon': new Image(),
                'oni': new Image(),
                'shadow': new Image(),
                'thunder': new Image(),
                'omega_boss': new Image()
            };
            
            // Exemplo de URLs - substitua pelas suas imagens
            gameState.bossImages['dragon'].src = 'imagem/dragao_boss.png';
            gameState.bossImages['oni'].src = 'imagem/oni_boss.png';
            gameState.bossImages['shadow'].src = 'imagem/shadow_boss.png';
            gameState.bossImages['thunder'].src = 'imagem/trovao_boss.png';
            gameState.bossImages['omega_boss'].src = 'imagem/omega-boss_boss.png';
        }

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 20;
                this.health = config.playerHealth;
                this.maxHealth = config.playerHealth;
                this.speed = config.playerSpeed;
                this.angle = 0;
                this.burning = null;
                this.shocked = false;
                this.shockTimer = 0;
                this.slowed = false;
                this.slowTimer = 0;
                this.originalSpeed = this.speed;
                this.lastMoveTime = 0;
            }

            update(deltaTime) {
                let moveX = 0;
                let moveY = 0;

                if (gameState.keys['KeyW']) moveY -= 1;
                if (gameState.keys['KeyS']) moveY += 1;
                if (gameState.keys['KeyA']) moveX -= 1;
                if (gameState.keys['KeyD']) moveX += 1;

                if (moveX !== 0 || moveY !== 0) {
                    this.lastMoveTime = Date.now();
                    gameState.isStandingStill = false;
                } else {
                    if (!gameState.isStandingStill) {
                        gameState.lastStandStillTime = Date.now();
                        gameState.isStandingStill = true;
                    }
                }

                if (moveX !== 0 && moveY !== 0) {
                    moveX *= 0.7071;
                    moveY *= 0.7071;
                }

                const effectiveSpeed = this.slowed ? this.speed * 0.7 : this.speed;
                this.x += moveX * effectiveSpeed;
                this.y += moveY * effectiveSpeed;

                const borderBuffer = 5;
                this.x = Math.max(this.radius + borderBuffer, Math.min(gameState.canvas.width - this.radius - borderBuffer, this.x));
                this.y = Math.max(this.radius + borderBuffer, Math.min(gameState.canvas.height - this.radius - borderBuffer, this.y));

                this.angle = Math.atan2(gameState.mouse.y - this.y, gameState.mouse.x - this.x);
                
                if (this.burning) {
                    this.burning.timer += deltaTime;
                    if (this.burning.timer >= 1000) {
                        this.takeDamage(this.burning.damage);
                        this.burning.timer = 0;
                    }
                    if (this.burning.timer >= this.burning.duration) {
                        this.burning = null;
                    }
                }
                
                if (this.shocked) {
                    this.shockTimer += deltaTime;
                    if (this.shockTimer >= 500) {
                        this.takeDamage(2);
                        this.shockTimer = 0;
                    }
                    if (this.shockTimer >= this.shockDuration) {
                        this.shocked = false;
                        this.speed = this.originalSpeed;
                    }
                }

                if (this.slowed) {
                    this.slowTimer += deltaTime;
                    if (this.slowTimer >= 3000) {
                        this.slowed = false;
                        this.speed = this.originalSpeed;
                    }
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                
                if (this.shocked) {
                    ctx.fillStyle = '#00f';
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * this.radius * 1.5;
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 2, 0, Math.PI * 2);
                        ctx.fillStyle = '#0ff';
                        ctx.fill();
                    }
                } else if (this.burning) {
                    ctx.fillStyle = '#f80';
                } else if (this.slowed) {
                    ctx.fillStyle = '#00f';
                } else {
                    ctx.fillStyle = '#333';
                }
                
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.8, 0, Math.PI);
                ctx.fillStyle = '#000';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(-this.radius * 0.3, -this.radius * 0.2, this.radius * 0.1, 0, Math.PI * 2);
                ctx.arc(this.radius * 0.3, -this.radius * 0.2, this.radius * 0.1, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                
                ctx.restore();
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    if (gameState.secondWind && !gameState.usedSecondWind) {
                        this.health = this.maxHealth * 0.5;
                        gameState.usedSecondWind = true;
                        createParticles(this.x, this.y, 30, '#0ff');
                    } else {
                        this.health = 0;
                        gameState.gameOver = true;
                    }
                }
            }
            
            applyBurn(damage, duration) {
                this.burning = { damage, duration, timer: 0 };
            }
            
            applyShock(duration) {
                this.shocked = true;
                this.shockTimer = 0;
                this.shockDuration = duration;
                this.speed = this.originalSpeed * 0.7;
                
                Shuriken.prototype.damage *= 0.6;
                setTimeout(() => {
                    Shuriken.prototype.damage /= 0.6;
                }, duration);
            }

            applySlow(amount, duration) {
                this.slowed = true;
                this.slowTimer = 0;
                this.speed = this.originalSpeed * (1 - amount);
                this.slowDuration = duration;
            }
        }

        class Shuriken {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = config.shurikenSpeed;
                this.radius = 8;
                this.damage = 11 * gameState.damageMultiplier;
                this.lifetime = 2000;
                this.piercing = false;
                this.explosive = false;
                this.ice = false;
                this.atomic = false;
                this.stone = false;
                this.critical = false;
                this.pinkPiercing = false;
            }

            update(deltaTime) {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.lifetime -= deltaTime;

                const borderBuffer = 5;
                if (this.x < borderBuffer || this.x > gameState.canvas.width - borderBuffer || 
                    this.y < borderBuffer || this.y > gameState.canvas.height - borderBuffer) {
                    this.lifetime = 0;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI/4);
                
                let fillColor = '#fff';
                let strokeColor = '#f00';
                
                if (this.explosive) {
                    fillColor = '#f80';
                    strokeColor = '#f00';
                } else if (this.ice) {
                    fillColor = '#0ff';
                    strokeColor = '#00f';
                } else if (this.atomic) {
                    fillColor = '#f0f';
                    strokeColor = '#0f0';
                } else if (this.stone) {
                    fillColor = '#8B4513';
                    strokeColor = '#A0522D';
                } else if (this.pinkPiercing) {
                    fillColor = '#FF69B4';
                    strokeColor = '#FF1493';
                }
                
                ctx.beginPath();
                ctx.moveTo(0, -this.radius);
                ctx.lineTo(this.radius, 0);
                ctx.lineTo(0, this.radius);
                ctx.lineTo(-this.radius, 0);
                ctx.closePath();
                ctx.fillStyle = fillColor;
                ctx.fill();
                
                if (this.critical) {
                    ctx.strokeStyle = '#f00';
                } else {
                    ctx.strokeStyle = strokeColor;
                }
                
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.restore();
            }
        }

        class FireBreathProjectile {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 12;
                this.radius = 12;
                this.damage = 2;
                this.lifetime = 2000;
            }

            update(deltaTime) {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.lifetime -= deltaTime;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.beginPath();
                ctx.moveTo(0, -this.radius * 0.5);
                ctx.quadraticCurveTo(this.radius * 1.5, 0, 0, this.radius * 0.5);
                ctx.quadraticCurveTo(-this.radius * 1.5, 0, 0, -this.radius * 0.5);
                ctx.closePath();
                
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 1.5);
                gradient.addColorStop(0, '#ff6600');
                gradient.addColorStop(0.5, '#ff3300');
                gradient.addColorStop(1, '#ff0000');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.restore();
            }
        }

        class DarkMatterProjectile {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 8;
                this.radius = 10;
                this.damage = 10;
                this.lifetime = 3000;
            }

            update(deltaTime) {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.lifetime -= deltaTime;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
                gradient.addColorStop(0, '#9b59b6');
                gradient.addColorStop(1, '#8e44ad');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.restore();
            }
        }

        class MiniDragon {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.speed = 4;
                this.health = 20;
                this.maxHealth = 20;
                this.damage = 5;
                this.color = '#f80';
                this.xpValue = 0;
                this.attackCooldown = 1000;
                this.lastAttack = 0;
                this.directionChangeTimer = 0;
                this.directionChangeInterval = 900;
                this.angle = Math.random() * Math.PI * 2;
                this.stunned = false;
                this.stunTimer = 0;
                this.stunDuration = 0;
            }

            update(deltaTime) {
                if (this.stunned) {
                    this.stunTimer += deltaTime;
                    if (this.stunTimer >= this.stunDuration) {
                        this.stunned = false;
                    }
                    return;
                }
                
                this.directionChangeTimer += deltaTime;
                this.lastAttack += deltaTime;
                
                if (this.directionChangeTimer >= this.directionChangeInterval) {
                    const targetAngle = Math.atan2(
                        gameState.player.y - this.y,
                        gameState.player.x - this.x
                    );
                    this.angle = targetAngle + (Math.random() - 0.5) * Math.PI/2;
                    this.directionChangeTimer = 0;
                }
                
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                const dx = gameState.player.x - this.x;
                const dy = gameState.player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < this.radius + gameState.player.radius && this.lastAttack >= this.attackCooldown) {
                    gameState.player.takeDamage(this.damage);
                    this.lastAttack = 0;
                }
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                if (this.stunned) {
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * this.radius * 1.5;
                        ctx.beginPath();
                        ctx.arc(this.x + Math.cos(angle) * dist, this.y + Math.sin(angle) * dist, 2, 0, Math.PI * 2);
                        ctx.fillStyle = '#fff';
                        ctx.fill();
                    }
                }
                
                ctx.beginPath();
                ctx.moveTo(this.x - this.radius * 0.7, this.y);
                ctx.lineTo(this.x - this.radius * 1.5, this.y - this.radius * 0.8);
                ctx.lineTo(this.x - this.radius * 1.5, this.y + this.radius * 0.8);
                ctx.closePath();
                ctx.fillStyle = '#f60';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(this.x + this.radius * 0.5, this.y - this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(this.x + this.radius * 0.8, this.y, this.radius * 0.3, 0.1, Math.PI - 0.1);
                ctx.fillStyle = '#f00';
                ctx.fill();
            }

            takeDamage(amount) {
                this.health -= amount;
                return this.health <= 0;
            }
            
            applyStun(duration) {
                this.stunned = true;
                this.stunTimer = 0;
                this.stunDuration = duration;
            }
        }

        class ThunderProjectile {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 8;
                this.width = 15;
                this.height = 120;
                this.damage = 11;
                this.lifetime = 1500;
                this.distanceTraveled = 0;
            }

            update(deltaTime) {
                const moveX = Math.cos(this.angle) * this.speed;
                const moveY = Math.sin(this.angle) * this.speed;
                
                this.x += moveX;
                this.y += moveY;
                this.distanceTraveled += Math.sqrt(moveX * moveX + moveY * moveY);
                this.lifetime -= deltaTime;
                
                const player = gameState.player;
                const playerLeft = player.x - player.radius;
                const playerRight = player.x + player.radius;
                const playerTop = player.y - player.radius;
                const playerBottom = player.y + player.radius;
                
                const projLeft = this.x - this.width/2;
                const projRight = this.x + this.width/2;
                const projTop = this.y - this.height/2;
                const projBottom = this.y + this.height/2;
                
                if (projRight > playerLeft && projLeft < playerRight &&
                    projBottom > playerTop && projTop < playerBottom) {
                    player.takeDamage(this.damage);
                    player.applyShock(3000); 
                    this.lifetime = 0;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = '#0af';
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 2;
                
                for (let i = 0; i < 5; i++) {
                    const offset = (Math.random() - 0.5) * 10;
                    ctx.beginPath();
                    ctx.moveTo(-this.width/2 + offset, -this.height/2);
                    ctx.lineTo(this.width/2 + offset, this.height/2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        class DarkMatterPool {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 110;
                this.lifetime = 6000;
                this.damageTimer = 0;
            }
            
            update(deltaTime) {
                this.lifetime -= deltaTime;
                this.damageTimer += deltaTime;
                
                const player = gameState.player;
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < this.radius + player.radius && this.damageTimer >= 500) {
                    player.takeDamage(10);
                    player.applySlow(0.2, 3000);
                    this.damageTimer = 0;
                }
            }
            
            draw(ctx) {
                ctx.globalAlpha = 0.5 * (this.lifetime / 3000);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0, 
                    this.x, this.y, this.radius
                );
                gradient.addColorStop(0, '#8e44ad');
                gradient.addColorStop(1, '#2c3e50');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        class ExplosionHitbox {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
            }
        }

        class ToxicCloud {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 75;
                this.lifetime = 3000;
                this.damage = 0;
                this.timer = 0;
            }
            
            update(deltaTime) {
                this.lifetime -= deltaTime;
                this.timer += deltaTime;
                
                if (this.timer >= 500) {
                    this.timer = 0;
                    for (const enemy of gameState.enemies) {
                        const dx = enemy.x - this.x;
                        const dy = enemy.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < this.radius) {
                            enemy.takeDamage(enemy.maxHealth * 0.1);
                            createParticles(enemy.x, enemy.y, 2, '#0f0');
                        }
                    }
                }
            }
            
            draw(ctx) {
                ctx.globalAlpha = 0.3 * (this.lifetime / 3000);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#0f0';
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = 15;
                this.speed = 2;
                this.health = 30;
                this.maxHealth = 30;
                this.damage = 5;
                this.color = '#f00';
                this.xpValue = 50;
                this.attackCooldown = 1000;
                this.lastAttack = 0;
                this.specialAbilityCooldown = 5000;
                this.lastSpecialAbility = 0;
                this.isElite = false;
                this.isBoss = false;
                this.slowed = false;
                this.slowAmount = 0;
                this.slowTimer = 0;
                this.originalSpeed = this.speed;
                this.defense = 0;
                this.poison = null;
                this.burn = null;
                this.stunned = false;
                this.stunTimer = 0;
                this.stunDuration = 0;
                this.originalDamage = this.damage;
                this.iceSlowTimer = 0;
                this.iceSlowDuration = 2000;
                
                this.explosionHitbox = new ExplosionHitbox(this.x, this.y, this.radius * 1.5);
                gameState.explosionHitboxes.push(this.explosionHitbox);
                
                switch(type) {
                    case 'weak':
                        this.radius = 12;
                        this.speed = 2.8;
                        this.health = 20;
                        this.maxHealth = 20;
                        this.damage = 10;
                        this.color = '#f88';
                        this.xpValue = 50;
                        break;
                    case 'medium':
                        this.radius = 15;
                        this.speed = 2.2;
                        this.health = 35;
                        this.maxHealth = 35;
                        this.damage = 15;
                        this.color = '#f55';
                        this.xpValue = 80;
                        break;
                    case 'strong':
                        this.radius = 18;
                        this.speed = 2;
                        this.health = 60;
                        this.maxHealth = 60;
                        this.damage = 20;
                        this.color = '#f00';
                        this.xpValue = 110;
                        break;
                    case 'elite':
                        this.radius = 22;
                        this.speed = 2.7;
                        this.health = 100;
                        this.maxHealth = 100;
                        this.damage = 20;
                        this.color = '#c00';
                        this.xpValue = 160;
                        this.isElite = true;
                        this.specialAbilityCooldown = 4000;
                        break;
                    case 'tank':
                        this.radius = 25;
                        this.speed = 2.1;
                        this.health = 150;
                        this.maxHealth = 150;
                        this.damage = 45;
                        this.color = '#880';
                        this.xpValue = 200;
                        this.isElite = true;
                        break;
                    case 'assassin':
                        this.radius = 10;
                        this.speed = 3.5;
                        this.health = 15;
                        this.maxHealth = 15;
                        this.damage = 60;
                        this.color = '#808';
                        this.xpValue = 180;
                        this.isElite = true;
                        break;
                }
                
                const waveMultiplier = Math.pow(1.2, gameState.wave - 1);
                this.health *= waveMultiplier;
                this.maxHealth = this.health;
                this.originalSpeed = this.speed;
                this.originalDamage = this.damage;
            }

            update(deltaTime) {
                if (this.stunned) {
                    this.stunTimer += deltaTime;
                    if (this.stunTimer >= this.stunDuration) {
                        this.stunned = false;
                    }
                    return;
                }
                
                this.explosionHitbox.x = this.x;
                this.explosionHitbox.y = this.y;
                this.lastAttack += deltaTime;
                
                if (this.iceSlowTimer > 0) {
                    this.iceSlowTimer -= deltaTime;
                    if (this.iceSlowTimer <= 0) {
                        this.speed = this.originalSpeed;
                        this.color = this.type === 'weak' ? '#f88' : 
                                     this.type === 'medium' ? '#f55' : 
                                     this.type === 'strong' ? '#f00' : '#c00';
                    }
                }
                
                if (this.slowed) {
                    this.slowTimer += deltaTime;
                    if (this.slowTimer >= 3000) {
                        this.slowed = false;
                        this.speed = this.originalSpeed;
                        this.color = this.type === 'weak' ? '#f88' : 
                                     this.type === 'medium' ? '#f55' : 
                                     this.type === 'strong' ? '#f00' : '#c00';
                    }
                }
                
                if (this.poison) {
                    this.poison.timer += deltaTime;
                    if (this.poison.timer >= 300) {
                        this.takeDamage(this.poison.damage);
                        this.poison.timer = 0;
                        createParticles(this.x, this.y, 2, '#0f0');
                    }
                    if (this.poison.timer >= this.poison.duration) {
                        this.poison = null;
                        this.color = this.type === 'weak' ? '#f88' : 
                                     this.type === 'medium' ? '#f55' : 
                                     this.type === 'strong' ? '#f00' : '#c00';
                        this.damage = this.originalDamage;
                    }
                }
                
                if (this.burn) {
                    this.burn.timer += deltaTime;
                    if (this.burn.timer >= 700) {
                        this.takeDamage(this.burn.damage);
                        this.burn.timer = 0;
                        createParticles(this.x, this.y, 2, '#f80');
                    }
                    if (this.burn.timer >= this.burn.duration) {
                        this.burn = null;
                        this.color = this.type === 'weak' ? '#f88' : 
                                     this.type === 'medium' ? '#f55' : 
                                     this.type === 'strong' ? '#f00' : '#c00';
                    }
                }
                
                const dx = gameState.player.x - this.x;
                const dy = gameState.player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
                
                if (dist < this.radius + gameState.player.radius && this.lastAttack >= this.attackCooldown) {
                    gameState.player.takeDamage(this.damage);
                    this.lastAttack = 0;
                }
                
                if (this.isElite && !this.isBoss) {
                    this.lastSpecialAbility += deltaTime;
                    if (this.lastSpecialAbility >= this.specialAbilityCooldown) {
                        this.useSpecialAbility();
                        this.lastSpecialAbility = 0;
                    }
                }
            }

            useSpecialAbility() {
                switch(this.type) {
                    case 'elite':
                        this.color = '#0ff';
                        this.damage *= 1.5;
                        setTimeout(() => {
                            this.color = '#c00';
                            this.damage = 15;
                        }, 3000);
                        break;
                    case 'tank':
                        this.health = Math.min(this.maxHealth, this.health + this.maxHealth * 0.3);
                        createParticles(this.x, this.y, 15, '#0f0');
                        break;
                    case 'assassin':
                        const angle = Math.atan2(
                            gameState.player.y - this.y,
                            gameState.player.x - this.x
                        );
                        this.x = gameState.player.x - Math.cos(angle) * 100;
                        this.y = gameState.player.y - Math.sin(angle) * 100;
                        createParticles(this.x, this.y, 10, '#f0f');
                        break;
                }
            }

            applySlow(amount) {
                if (this.isBoss) return;
                
                this.slowTimer = 0;
                this.slowAmount = Math.min(0.7, this.slowAmount + amount);
                this.speed = this.originalSpeed * (1 - this.slowAmount);
                this.color = '#00f';
                this.slowed = true;
            }

            applyIceSlow() {
                if (this.isBoss) return;
                
                this.iceSlowTimer = this.iceSlowDuration;
                this.slowAmount = Math.min(0.6, this.slowAmount + 0.1);
                this.speed = this.originalSpeed * (1 - this.slowAmount);
                this.color = '#0ff';
            }

            takeDamage(amount) {
                const damageTaken = amount * (1 - this.defense);
                this.health -= damageTaken;
                
                if (this.isBoss) {
                    this.defense = Math.min(0.7, (1 - (this.health / this.maxHealth)) * 0.7);
                }
                
                if (this.health <= 0) {
                    if (this.burn && this.burn.damage >= this.health) {
                        createParticles(this.x, this.y, 15, '#f80');
                    }
                    return true;
                }
                return false;
            }
            
            applyStun(duration) {
                this.stunned = true;
                this.stunTimer = 0;
                this.stunDuration = duration;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                if (this.stunned) {
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * this.radius * 1.5;
                        ctx.beginPath();
                        ctx.arc(this.x + Math.cos(angle) * dist, this.y + Math.sin(angle) * dist, 2, 0, Math.PI * 2);
                        ctx.fillStyle = '#fff';
                        ctx.fill();
                    }
                }
                
                if (this.type === 'assassin') {
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.radius * 0.6, this.y - this.radius * 0.3);
                    ctx.lineTo(this.x - this.radius * 0.3, this.y - this.radius * 0.4);
                    ctx.lineTo(this.x - this.radius * 0.4, this.y - this.radius * 0.2);
                    ctx.closePath();
                    
                    ctx.moveTo(this.x + this.radius * 0.6, this.y - this.radius * 0.3);
                    ctx.lineTo(this.x + this.radius * 0.3, this.y - this.radius * 0.4);
                    ctx.lineTo(this.x + this.radius * 0.4, this.y - this.radius * 0.2);
                    ctx.closePath();
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x - this.radius * 0.4, this.y - this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
                    ctx.arc(this.x + this.radius * 0.4, this.y - this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                }
                
                ctx.beginPath();
                if (this.type === 'tank') {
                    ctx.arc(this.x, this.y + this.radius * 0.2, this.radius * 0.4, 0.1, Math.PI - 0.1);
                } else {
                    ctx.arc(this.x, this.y + this.radius * 0.2, this.radius * 0.3, 0, Math.PI);
                }
                ctx.fillStyle = '#000';
                ctx.fill();
                
                if (this.health < this.maxHealth) {
                    const healthPercent = this.health / this.maxHealth;
                    ctx.fillStyle = '#f00';
                    ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, this.radius * 2 * healthPercent, 3);
                }
            }
        }

        class Boss extends Enemy {
            constructor(type) {
                super(0, 0, 'strong');
                this.type = type;
                this.radius = 55;
                this.speed = 1.5;
                this.health = 800;
                this.maxHealth = 800;
                this.damage = 30;
                this.color = '#800';
                this.xpValue = 1000;
                this.attackCooldown = 2000;
                this.lastAttack = 0;
                this.phase = 1;
                this.abilityCooldown = 5000;
                this.lastAbility = 0;
                this.name = "Boss";
                this.isBoss = true;
                this.fireBreathCooldown = 8000;
                this.lastFireBreath = 0;
                this.miniDragonCooldown = 5000;
                this.lastMiniDragon = 0;
                this.image = null;
                this.imageElement = null;
                
                switch(type) {
                    case 'dragon':
                        this.health = 800;
                        this.maxHealth = 800;
                        this.speed = 2.4;
                        this.damage = 40;
                        this.color = '#f80';
                        this.name = "Dragão Ninja";
                        this.miniDragonCooldown = 8000; 
                        break;
                    case 'oni':
                        this.health = 900;
                        this.maxHealth = 900;
                        this.speed = 3.0;
                        this.damage = 35;
                        this.color = '#f0f';
                        this.name = "Guerreiro Oni";
                        break;
                    case 'shadow':
                        this.health = 1000;
                        this.maxHealth = 1000;
                        this.speed = 2.8;
                        this.damage =55;
                        this.color = '#08f';
                        this.name = "Mestre das Sombras";
                        break;
                    case 'thunder':
                        this.health = 850;
                        this.maxHealth = 850;
                        this.speed = 3.3;
                        this.damage = 37;
                        this.color = '#ff0';
                        this.name = "Deus do Trovão";
                        this.abilityCooldown = 6000;
                        break;
                }
                
                const waveMultiplier = Math.pow(1.2, gameState.wave - 1);
                this.health *= waveMultiplier;
                this.maxHealth = this.health;
                
                // Configurar imagem do boss
                this.image = gameState.bossImages[type];
                
                // Criar elemento de imagem para o boss
                this.imageElement = document.createElement('img');
                this.imageElement.className = 'boss-image';
                this.imageElement.src = this.image.src;
                this.imageElement.style.width = `${this.radius * 3}px`;
                this.imageElement.style.height = `${this.radius * 3}px`;
                document.body.appendChild(this.imageElement);
                
                const side = Math.floor(Math.random() * 4);
                switch(side) {
                    case 0:
                        this.x = Math.random() * gameState.canvas.width;
                        this.y = -this.radius;
                        break;
                    case 1:
                        this.x = gameState.canvas.width + this.radius;
                        this.y = Math.random() * gameState.canvas.height;
                        break;
                    case 2:
                        this.x = Math.random() * gameState.canvas.width;
                        this.y = gameState.canvas.height + this.radius;
                        break;
                    case 3:
                        this.x = -this.radius;
                        this.y = Math.random() * gameState.canvas.height;
                        break;
                }
            }

            update(deltaTime) {
                super.update(deltaTime);
                
                // Atualizar posição da imagem
                if (this.imageElement) {
                    this.imageElement.style.left = `${this.x + gameState.canvas.offsetLeft}px`;
                    this.imageElement.style.top = `${this.y + gameState.canvas.offsetTop}px`;
                }
                
                this.lastAbility += deltaTime;
                if (this.lastAbility >= this.abilityCooldown) {
                    this.useSpecialAbility();
                    this.lastAbility = 0;
                }
                
                if (this.type === 'dragon') {
                    this.lastFireBreath += deltaTime;
                    if (this.lastFireBreath >= this.fireBreathCooldown) {
                        this.useFireBreath();
                        this.lastFireBreath = 0;
                    }
                    
                    this.lastMiniDragon += deltaTime;
                    if (this.lastMiniDragon >= this.miniDragonCooldown) {
                        this.spawnMiniDragons();
                        this.lastMiniDragon = 0;
                    }
                }
                
                if (this.health <= this.maxHealth * 0.5 && this.phase === 1) {
                    this.phase = 2;
                    this.enterPhase2();
                }
            }

            useSpecialAbility() {
                switch(this.type) {
                    case 'dragon':
                        break;
                    case 'oni':
                        this.x = Math.random() * gameState.canvas.width;
                        this.y = Math.random() * gameState.canvas.height;
                        
                        for (let i = 0; i < 11; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const fire = new Enemy(
                                this.x + Math.cos(angle) * 100,
                                this.y + Math.sin(angle) * 100,
                                'weak'
                            );
                            fire.speed = 0;
                            fire.damage = 15;
                            fire.color = '#f0f';
                            fire.radius = 15;
                            fire.xpValue = 0;
                            fire.lifetime = 3000;
                            
                            gameState.enemies.push(fire);
                        }
                        break;
                    case 'shadow':
                        for (let i = 0; i < 3; i++) {
                            const clone = new Enemy(
                                this.x + (Math.random() - 0.5) * 100,
                                this.y + (Math.random() - 0.5) * 100,
                                'strong'
                            );
                            clone.color = '#08f';
                            clone.speed = this.speed * 1.4;
                            clone.xpValue = 0;
                            clone.lifetime = 3000;
                            
                            gameState.enemies.push(clone);
                        }
                        break;
                    case 'thunder':
                        const angleToPlayer = Math.atan2(
                            gameState.player.y - this.y,
                            gameState.player.x - this.x
                        );
                        
                        for (let i = 0; i < 2; i++) {
                            const angle = angleToPlayer + (i - 2) * 0.1;
                            
                            const projectile = new ThunderProjectile(
                                this.x,
                                this.y,
                                angle
                            );
                            gameState.shurikens.push(projectile);
                        }
                        break;
                }
            }

            useFireBreath() {
                for (let i = 0; i < 25; i++) {
                    const angle = Math.atan2(
                        gameState.player.y - this.y,
                        gameState.player.x - this.x
                    ) + (Math.random() - 0.5) * 0.5;
                    
                    const fireProjectile = new FireBreathProjectile(
                        this.x + Math.cos(angle) * this.radius,
                        this.y + Math.sin(angle) * this.radius,
                        angle
                    );
                    gameState.shurikens.push(fireProjectile);
                }
            }
            
            spawnMiniDragons() {
                for (let i = 0; i < 2; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = this.radius * 0.8;
                    
                    const miniDragon = new MiniDragon(
                        this.x + Math.cos(angle) * distance,
                        this.y + Math.sin(angle) * distance
                    );
                    
                    gameState.enemies.push(miniDragon);
                }
            }

            enterPhase2() {
                switch(this.type) {
                    case 'dragon':
                        this.speed *= 1.5;
                        this.abilityCooldown = 3000;
                        this.fireBreathCooldown = 7000;
                        this.miniDragonCooldown = 3000; 
                        break;
                    case 'oni':
                        this.damage *= 1.5;
                        this.abilityCooldown = 2500;
                        break;
                    case 'shadow':
                        this.speed *= 1.3;
                        this.abilityCooldown = 2500;
                        break;
                    case 'thunder':
                        this.abilityCooldown = 1500;
                        break;
                }
            }

            draw(ctx) {
                // Desenhar apenas a hitbox esférica sem face
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.9, 0, Math.PI * 2);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                if (this.type === 'thunder' && this.phase === 2) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            takeDamage(amount) {
                const damageTaken = amount * (1 - this.defense);
                this.health -= damageTaken;
                
                if (this.health <= 0) {
                    gameState.bossActive = false;
                    gameState.score += this.xpValue;
                    gameState.xp += this.xpValue;
                    gameState.bossSpawned = false;
                    gameState.spawnTimer = 0;
                    
                    // Remover elemento de imagem quando o boss morrer
                    if (this.imageElement && this.imageElement.parentNode) {
                        this.imageElement.parentNode.removeChild(this.imageElement);
                    }
                    
                    return true;
                }
                
                this.defense = Math.min(0.7, (1 - (this.health / this.maxHealth)) * 0.7);
                return false;
            }
        }

        class OmegaBoss extends Enemy {
            constructor() {
                super(0, 0, 'strong');
                this.type = 'omega_boss';
                this.radius = 100;
                this.speed = 0;
                this.health = 7000;
                this.maxHealth = 7000;
                this.damage = 50;
                this.color = '#5b2c6f';
                this.xpValue = 5000;
                this.attackCooldown = 2000;
                this.lastAttack = 0;
                this.name = "Antigo Deus Caído";
                this.isBoss = true;
                this.teleportTimer = 0;
                this.teleportInterval = 2000;
                this.projectileTimer = 0;
                this.projectileInterval = 2500;
                this.spawnTimer = 0;
                this.spawnInterval = 3000;
                this.minionSpawned = false;
                this.minions = [];
                this.minionAttackTimer = 0;
                this.minionAttackInterval = 2000;
                this.image = null;
                this.imageElement = null;
                
                // Configurar imagem do Omega Boss
                this.image = gameState.bossImages['omega_boss'];
                
                // Criar elemento de imagem para o Omega Boss
                this.imageElement = document.createElement('img');
                this.imageElement.className = 'boss-image';
                this.imageElement.src = this.image.src;
                this.imageElement.style.width = `${this.radius * 3}px`;
                this.imageElement.style.height = `${this.radius * 3}px`;
                document.body.appendChild(this.imageElement);
                
                // Posição inicial aleatória
                this.x = Math.random() * (gameState.canvas.width - this.radius * 2) + this.radius;
                this.y = Math.random() * (gameState.canvas.height - this.radius * 2) + this.radius;
            }

            update(deltaTime) {
                super.update(deltaTime);
                
                // Atualizar posição da imagem
                if (this.imageElement) {
                    this.imageElement.style.left = `${this.x + gameState.canvas.offsetLeft}px`;
                    this.imageElement.style.top = `${this.y + gameState.canvas.offsetTop}px`;
                }
                
                this.teleportTimer += deltaTime;
                this.projectileTimer += deltaTime;
                this.spawnTimer += deltaTime;
                this.lastAttack += deltaTime;
                
                // Teleporte a cada 2 segundos
                if (this.teleportTimer >= this.teleportInterval) {
                    this.teleport();
                    this.teleportTimer = 0;
                }
                
                // Ataque de projéteis a cada 5 segundos
                if (this.projectileTimer >= this.projectileInterval) {
                    this.shootDarkMatter();
                    this.projectileTimer = 0;
                }
                
                // Spawn de inimigos
                if (this.spawnTimer >= this.spawnInterval) {
                    this.spawnEnemy();
                    this.spawnTimer = 0;
                }
                
                // Quando chegar a 35% de vida, spawna minions
                if (this.health <= this.maxHealth * 0.35 && !this.minionSpawned) {
                    this.spawnMinions();
                    this.minionSpawned = true;
                }
                
                // Atualizar minions
                if (this.minionSpawned) {
                    this.minionAttackTimer += deltaTime;
                    if (this.minionAttackTimer >= this.minionAttackInterval) {
                        this.minionsAttack();
                        this.minionAttackTimer = 0;
                    }
                }
                
                // Verificar colisão com o jogador
                const dx = gameState.player.x - this.x;
                const dy = gameState.player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < this.radius + gameState.player.radius && this.lastAttack >= this.attackCooldown) {
                    gameState.player.takeDamage(this.damage);
                    this.lastAttack = 0;
                }
            }

            teleport() {
                this.x = Math.random() * (gameState.canvas.width - this.radius * 2) + this.radius;
                this.y = Math.random() * (gameState.canvas.height - this.radius * 2) + this.radius;
                
                // Criar poça de matéria negra no local do teleporte
                const pool = new DarkMatterPool(this.x, this.y);
                gameState.particles.push(pool);
                
                createParticles(this.x, this.y, 20, '#8e44ad');
            }

            shootDarkMatter() {
                for (let i = 0; i < 70; i++) {
                    const angle = (i / 70) * Math.PI * 2;
                    const projectile = new DarkMatterProjectile(
                        this.x + Math.cos(angle) * this.radius,
                        this.y + Math.sin(angle) * this.radius,
                        angle
                    );
                    gameState.shurikens.push(projectile);
                }
            }

            spawnEnemy() {
                let type = 'weak';
                const rand = Math.random();
                
                if (gameState.wave >= 15 && rand < 0.1) {
                    type = 'thunder';
                    this.spawnInterval = 6000;
                } else if (gameState.wave >= 11 && rand < 0.2) {
                    type = 'assassin';
                    this.spawnInterval = 5000;
                } else if (gameState.wave >= 9 && rand < 0.3) {
                    type = 'tank';
                    this.spawnInterval = 4000;
                } else if (gameState.wave >= 7 && rand < 0.2) {
                    type = 'elite';
                    this.spawnInterval = 3000;
                } else if (gameState.wave >= 4 && rand < 0.4) {
                    type = 'strong';
                    this.spawnInterval = 2000;
                } else if (gameState.wave >= 2 && rand < 0.6) {
                    type = 'medium';
                    this.spawnInterval = 1000;
                } else {
                    type = 'weak';
                    this.spawnInterval = 500;
                }
                
                const angle = Math.random() * Math.PI * 2;
                const distance = this.radius * 0.8;
                
                const enemy = new Enemy(
                    this.x + Math.cos(angle) * distance,
                    this.y + Math.sin(angle) * distance,
                    type
                );
                
                gameState.enemies.push(enemy);
            }

            spawnMinions() {
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const distance = 150;
                    
                    const minion = {
                        x: this.x + Math.cos(angle) * distance,
                        y: this.y + Math.sin(angle) * distance,
                        radius: 15,
                        color: '#5b2c6f'
                    };
                    
                    this.minions.push(minion);
                    createParticles(minion.x, minion.y, 10, '#8e44ad');
                }
            }

            minionsAttack() {
                for (const minion of this.minions) {
                    const angle = Math.atan2(
                        gameState.player.y - minion.y,
                        gameState.player.x - minion.x
                    );
                    
                    const projectile = new DarkMatterProjectile(
                        minion.x,
                        minion.y,
                        angle
                    );
                    projectile.radius = 8;
                    projectile.damage = 5;
                    projectile.speed = 6;
                    
                    gameState.shurikens.push(projectile);
                }
            }

            takeDamage(amount) {
                const damageTaken = amount * (1 - this.defense);
                this.health -= damageTaken;
                
                if (this.health <= 0) {
                    gameState.omegaBossActive = false;
                    gameState.score += this.xpValue;
                    gameState.xp += this.xpValue;
                    gameState.bossSpawned = false;
                    gameState.spawnTimer = 0;
                    
                    // Remover elemento de imagem quando o boss morrer
                    if (this.imageElement && this.imageElement.parentNode) {
                        this.imageElement.parentNode.removeChild(this.imageElement);
                    }
                    
                    return true;
                }
                
                this.defense = Math.min(0.7, (1 - (this.health / this.maxHealth)) * 0.7);
                return false;
            }

            draw(ctx) {
                // Desenhar apenas a hitbox esférica sem face
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, this.radius * 0.5,
                    this.x, this.y, this.radius
                );
                gradient.addColorStop(0, '#5b2c6f');
                gradient.addColorStop(1, '#2c3e50');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Barra de vida
                if (this.health < this.maxHealth) {
                    const healthPercent = this.health / this.maxHealth;
                    ctx.fillStyle = '#f00';
                    ctx.fillRect(this.x - this.radius, this.y - this.radius - 15, this.radius * 2 * healthPercent, 5);
                }
            }
        }

        class Particle {
            constructor(x, y, color, size, velocity, lifetime) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size;
                this.velocity = velocity;
                this.lifetime = lifetime;
                this.maxLifetime = lifetime;
            }

            update(deltaTime) {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.lifetime -= deltaTime;
            }

            draw(ctx) {
                const alpha = this.lifetime / this.maxLifetime;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        const powerupsByLevel = [
            null,
            [
                {
                    name: "Lançamento Letal",
                    description: "Shurikens se movem 30% mais rápido",
                    apply: () => {
                        config.shurikenSpeed *= 1.3;
                    }
                },
                {
                    name: "Com as Duas Mãos",
                    description: "25% de chance de lançar uma shuriken extra",
                    apply: () => {
                        gameState.doubleShotChance = 0.25;
                    }
                },
                {
                    name: "51 com Limão",
                    description: "Aumenta vida máxima em 50%",
                    apply: () => {
                        gameState.player.maxHealth *= 1.5;
                        gameState.player.health *= 1.5;
                    }
                }
            ],
            [
                {
                    name: "Shurikens de Fogo",
                    description: "Shurikens queimam inimigos causando dano por segundo",
                    apply: () => {
                        const originalTakeDamage = Enemy.prototype.takeDamage;
                        Enemy.prototype.takeDamage = function(amount) {
                            const died = originalTakeDamage.call(this, amount);
                            if (!died && !this.isBoss) {
                                this.burn = { damage: amount * 0.5, duration: 3000, timer: 0 };
                                this.color = '#f80';
                            }
                            return died;
                        };
                    }
                },
                {
                    name: "Shurikens de Pedra",
                    description: "10% de chance de nocautear os inimigos por 2.5 segundos",
                    apply: () => {
                        Shuriken.prototype.stone = true;
                        const originalTakeDamage = Enemy.prototype.takeDamage;
                        Enemy.prototype.takeDamage = function(amount) {
                            if (Math.random() < 0.1 && !this.isBoss) {
                                this.applyStun(2500);
                                createParticles(this.x, this.y, 10, '#fff');
                            }
                            return originalTakeDamage.call(this, amount);
                        };
                    }
                },
                {
                    name: "Shurikens de Gelo",
                    description: "Shurikens dão slow de 10% nos inimigos (máx 60%) por 2 segundos",
                    apply: () => {
                        Shuriken.prototype.ice = true;
                        const originalTakeDamage = Enemy.prototype.takeDamage;
                        Enemy.prototype.takeDamage = function(amount) {
                            const died = originalTakeDamage.call(this, amount);
                            if (!died && !this.isBoss) {
                                this.applyIceSlow();
                                createParticles(this.x, this.y, 3, '#0ff');
                            }
                            return died;
                        };
                    }
                }
            ],
            [
                {
                    name: "Shuriken Atômica",
                    description: "30% de chance de lançar uma shuriken que explode ao matar inimigos",
                    apply: () => {
                        gameState.atomicShurikenChance = 0.3;
                        Shuriken.prototype.damage = 11 * 1.4 * gameState.damageMultiplier;
                    }
                },
                {
                    name: "Velocidade Ninja",
                    description: "Move 30% mais rápido",
                    apply: () => {
                        gameState.player.speed *= 1.3;
                    }
                },
                {
                    name: "Furia Vingativa",
                    description: "Aumenta cadência de tiro ao acertar inimigos",
                    apply: () => {
                        gameState.furyStacks = 0;
                        const originalTakeDamage = Enemy.prototype.takeDamage;
                        Enemy.prototype.takeDamage = function(amount) {
                            const died = originalTakeDamage.call(this, amount);
                            if (!died) {
                                gameState.furyStacks = Math.min(40, gameState.furyStacks + 3);
                                config.shurikenCooldown = Math.max(100, 450 * (1 - gameState.furyStacks/100));
                            }
                            return died;
                        };
                    }
                }
            ],
            [
                {
                    name: "Shurikens Perfurantes",
                    description: "50% de chance de lançar projéteis perfurantes",
                    apply: () => {
                        const originalThrowShuriken = throwShuriken;
                        throwShuriken = (x, y, angle) => {
                            if (Math.random() < 0.5) {
                                const shuriken = new Shuriken(x, y, angle);
                                shuriken.pinkPiercing = true;
                                shuriken.damage = 11 * 0.7 * gameState.damageMultiplier;
                                shuriken.speed = config.shurikenSpeed * 1.3;
                                gameState.shurikens.push(shuriken);
                            } else {
                                originalThrowShuriken(x, y, angle);
                            }
                        };
                    }
                },
                {
                    name: "Shurikens Explosivas",
                    description: "Shurikens explodem ao atingir inimigos",
                    apply: () => {
                        Shuriken.prototype.explosive = true;
                        const originalUpdate = Shuriken.prototype.update;
                        Shuriken.prototype.update = function(deltaTime) {
                            const hit = originalUpdate.call(this, deltaTime);
                            
                            for (const hitbox of gameState.explosionHitboxes) {
                                const dx = this.x - hitbox.x;
                                const dy = this.y - hitbox.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < hitbox.radius) {
                                    createExplosion(this.x, this.y, 50, this.damage * 0.8);
                                    this.lifetime = 0;
                                    break;
                                }
                            }
                            
                            if (this.lifetime <= 0) {
                                createExplosion(this.x, this.y, 50, this.damage * 0.8);
                            }
                            return hit;
                        };
                    }
                },
                {
                    name: "Mestre do Arremesso",
                    description: "Reduz tempo entre shurikens em 30%",
                    apply: () => {
                        config.shurikenCooldown *= 0.7;
                    }
                }
            ],
            [
                {
                    name: "Mestre das Duas Mãos",
                    description: "Lança 2 shurikens de uma vez",
                    apply: () => {
                        const originalThrowShuriken = throwShuriken;
                        throwShuriken = (x, y, angle) => {
                            originalThrowShuriken(x, y, angle - 0.1);
                            originalThrowShuriken(x, y, angle + 0.1);
                        };
                    }
                },
                {
                    name: "Meditação",
                    description: "Regenera vida quando parado por 2 segundos",
                    apply: () => {
                        gameState.healthRegen = true;
                        gameState.lastMeditationHeal = 0;
                    }
                },
                {
                    name: "Profissional em Pontos Vitais",
                    description: "10% de chance de causar dano duplo",
                    apply: () => {
                        const originalTakeDamage = Enemy.prototype.takeDamage;
                        Enemy.prototype.takeDamage = function(amount) {
                            if (Math.random() < 0.1) {
                                amount *= 2;
                                createParticles(this.x, this.y, 10, '#ff0');
                                return originalTakeDamage.call(this, amount);
                            }
                            return originalTakeDamage.call(this, amount);
                        };
                    }
                }
            ],
            [
                {
                    name: "Shurikens Vampíricas",
                    description: "Cura 3% do dano causado",
                    apply: () => {
                        const originalTakeDamage = Enemy.prototype.takeDamage;
                        Enemy.prototype.takeDamage = function(amount) {
                            const died = originalTakeDamage.call(this, amount);
                            gameState.player.health = Math.min(
                                gameState.player.maxHealth,
                                gameState.player.health + amount * 0.03
                            );
                            return died;
                        };
                    }
                },
                {
                    name: "Mestre do Desespero",
                    description: "Fica 50% mais rápido quando vida está baixa",
                    apply: () => {
                        gameState.timeSlow = true;
                    }
                },
                {
                    name: "Último Esforço",
                    description: "Dano dobrado quando vida está abaixo de 35%",
                    apply: () => {
                        gameState.finalGambit = true;
                    }
                }
            ],
            [
                {
                    name: "Tempestade de Shurikens",
                    description: "Chance de lançar shurikens extras",
                    apply: () => {
                        const originalThrowShuriken = throwShuriken;
                        throwShuriken = (x, y, angle) => {
                            originalThrowShuriken(x, y, angle);
                            if (Math.random() < 0.3) {
                                for (let i = 0; i < 3; i++) {
                                    setTimeout(() => {
                                        originalThrowShuriken(
                                            x + (Math.random() - 0.5) * 20,
                                            y + (Math.random() - 0.5) * 20,
                                            angle + (Math.random() - 0.5) * 0.5
                                        );
                                    }, i * 100);
                                }
                            }
                        };
                    }
                },
                {
                    name: "Flash Step",
                    description: "20% de chance de evitar dano teletransportando",
                    apply: () => {
                        const originalTakeDamage = Player.prototype.takeDamage;
                        Player.prototype.takeDamage = function(amount) {
                            if (Math.random() < 0.2) {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = 100;
                                this.x += Math.cos(angle) * distance;
                                this.y += Math.sin(angle) * distance;
                                createParticles(this.x, this.y, 10, '#888');
                                this.invincible = true;
                                setTimeout(() => {
                                    this.invincible = false;
                                }, 400);
                                return;
                            }
                            originalTakeDamage.call(this, amount);
                        };
                    }
                },
                {
                    name: "Fúria do Dragão",
                    description: "Chance de ficar mais rápido e atirar mais rápido",
                    apply: () => {
                        gameState.dragonFuryActive = false;
                        setInterval(() => {
                            if (Math.random() < 0.15 && !gameState.dragonFuryActive) {
                                gameState.dragonFuryActive = true;
                                gameState.dragonFuryEndTime = Date.now() + 4000;
                                gameState.player.speed *= 1.4;
                                config.shurikenCooldown *= 0.4;
                                setTimeout(() => {
                                    gameState.player.speed /= 1.4;
                                    config.shurikenCooldown /= 0.4;
                                    gameState.dragonFuryActive = false;
                                }, 4000);
                            }
                        }, 5000);
                    }
                }
            ],
            [
                {
                    name: "Shurikens Venenosas",
                    description: "Inimigos sofrem envenenamento por 2s",
                    apply: () => {
                        const originalTakeDamage = Enemy.prototype.takeDamage;
                        Enemy.prototype.takeDamage = function(amount) {
                            const died = originalTakeDamage.call(this, amount);
                            if (!died && !this.isBoss) {
                                this.poison = { damage: amount * 0.33, duration: 2000, timer: 0 };
                                this.color = '#0f0';
                                this.damage = this.originalDamage * 0.7;
                            }
                            return died;
                        };
                    }
                },
                {
                    name: "Nuvem Tóxica",
                    description: "Cria área com gás tóxico ao matar inimigos",
                    apply: () => {
                        gameState.toxicCloud = true;
                    }
                },
                {
                    name: "Com Todos os Membros",
                    description: "Joga shurikens em todas as direções periodicamente",
                    apply: () => {
                        gameState.lastOmniSlashTime = 0;
                        setInterval(() => {
                            if (Date.now() - gameState.lastOmniSlashTime >= 10000) {
                                gameState.lastOmniSlashTime = Date.now();
                                for (let i = 0; i < 40; i++) {
                                    const angle = (i / 40) * Math.PI * 2;
                                    throwShuriken(
                                        gameState.player.x,
                                        gameState.player.y,
                                        angle
                                    );
                                }
                            }
                        }, 1000);
                    }
                }
            ],
            [
                {
                    name: "Assassino Classe S",
                    description: "Teleporta curtas distâncias ao matar inimigos",
                    apply: () => {
                        gameState.shadowStep = true;
                    }
                },
                {
                    name: "Sede de Sangue",
                    description: "Regenera 8% de vida ao matar inimigos",
                    apply: () => {
                        gameState.bloodlust = true;
                    }
                },
                {
                    name: "O Ultimo Suspiro",
                    description: "Triplo de dano quando vida está abaixo de 35%",
                    apply: () => {
                        gameState.finalGambit = true;
                    }
                }
            ],
            [
                {
                    name: "Deus do Lançamento Letal",
                    description: "Ocasionalmente lança uma rajada de shurikens",
                    apply: () => {
                        gameState.omnislash = true;
                    }
                },
                {
                    name: "Chance Divina",
                    description: "Revive uma vez com 50% de vida ao morrer",
                    apply: () => {
                        gameState.secondWind = true;
                        gameState.usedSecondWind = false;
                    }
                },
                {
                    name: "Zênite",
                    description: "Todos os atributos aumentados em 70%",
                    apply: () => {
                        config.shurikenSpeed *= 1.70;
                        Shuriken.prototype.damage *= 1.70;
                        gameState.player.speed *= 1.50;
                        gameState.player.maxHealth *= 1.70;
                        gameState.player.health *= 1.70;
                        config.shurikenCooldown *= 0.75;
                    }
                }
            ]
        ];

        function init() {
            gameState.canvas = document.getElementById('gameCanvas');
            gameState.ctx = gameState.canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            window.addEventListener('keydown', (e) => {
                gameState.keys[e.code] = true;
                
                if (gameState.currentPowerups.length > 0) {
                    if (e.code === 'Digit1') {
                        selectPowerUpByIndex(0);
                    } else if (e.code === 'Digit2') {
                        selectPowerUpByIndex(1);
                    } else if (e.code === 'Digit3') {
                        selectPowerUpByIndex(2);
                    }
                }
            });
            
            window.addEventListener('keyup', (e) => {
                gameState.keys[e.code] = false;
            });
            
            gameState.canvas.addEventListener('mousemove', (e) => {
                const rect = gameState.canvas.getBoundingClientRect();
                gameState.mouse.x = e.clientX - rect.left;
                gameState.mouse.y = e.clientY - rect.top;
            });
            
            gameState.canvas.addEventListener('mousedown', (e) => {
                gameState.mouse.isDown = true;
            });
            
            gameState.canvas.addEventListener('mouseup', (e) => {
                gameState.mouse.isDown = false;
            });
            
            document.getElementById('powerup-btn-1').addEventListener('click', () => selectPowerUpByIndex(0));
            document.getElementById('powerup-btn-2').addEventListener('click', () => selectPowerUpByIndex(1));
            document.getElementById('powerup-btn-3').addEventListener('click', () => selectPowerUpByIndex(2));
            
            document.getElementById('restart-btn').addEventListener('click', resetGame);
            
            resetGame();
            gameLoop(0);
        }

        function resizeCanvas() {
            gameState.canvas.width = window.innerWidth;
            gameState.canvas.height = window.innerHeight;
        }

        function resetGame() {
            gameState.player = new Player(
                gameState.canvas.width / 2,
                gameState.canvas.height / 2
            );
            
            gameState.shurikens = [];
            gameState.enemies = [];
            gameState.bosses = [];
            gameState.particles = [];
            gameState.explosionHitboxes = [];
            gameState.wave = 10;
            gameState.waveTimer = 0;
            gameState.score = 0;
            gameState.xp = 100000;
            gameState.xpToLevel = config.xpRequirements[0];
            gameState.level = 1;
            gameState.gameOver = false;
            gameState.spawnTimer = 0;
            gameState.shurikenTimer = 0;
            gameState.activePowerups = [];
            gameState.bossActive = false;
            gameState.bossSpawned = false;
            gameState.currentPowerups = [];
            gameState.doubleShotChance = 0;
            gameState.atomicShurikenChance = 0;
            gameState.usedSecondWind = false;
            gameState.shocked = false;
            gameState.shockTimer = 0;
            gameState.miniDragonTimer = 0;
            gameState.omegaBossActive = false;
            gameState.damageMultiplier = 1;
            gameState.furyStacks = 0;
            gameState.lastMeditationHeal = 0;
            gameState.lastStandStillTime = 0;
            gameState.isStandingStill = false;
            gameState.dragonFuryActive = false;
            gameState.dragonFuryEndTime = 0;
            gameState.lastOmniSlashTime = 0;
            
            config.shurikenSpeed = 10;
            config.shurikenCooldown = 350;
            Shuriken.prototype.damage = 10;
            Shuriken.prototype.radius = 8;
            Shuriken.prototype.piercing = false;
            Shuriken.prototype.explosive = false;
            Shuriken.prototype.ice = false;
            Shuriken.prototype.atomic = false;
            Shuriken.prototype.stone = false;
            Shuriken.prototype.critical = false;
            Shuriken.prototype.pinkPiercing = false;
            
            gameState.healthRegen = false;
            gameState.timeSlow = false;
            gameState.ninjaDash = false;
            gameState.dodgeChance = 0;
            gameState.shadowStep = false;
            gameState.bloodlust = false;
            gameState.toxicCloud = false;
            gameState.omnislash = false;
            gameState.secondWind = false;
            gameState.finalGambit = false;
            
            throwShuriken = originalThrowShuriken;
            
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('powerups').style.display = 'none';
            document.getElementById('boss-health').style.display = 'none';
            document.getElementById('powerup-buttons').style.display = 'none';
            
            updateUI();
        }

        function originalThrowShuriken(x, y, angle) {
            const shuriken = new Shuriken(x, y, angle);
            
            if (gameState.atomicShurikenChance > 0 && Math.random() < gameState.atomicShurikenChance) {
                shuriken.atomic = true;
            }
            
            gameState.shurikens.push(shuriken);
            
            if (gameState.doubleShotChance > 0 && Math.random() < gameState.doubleShotChance) {
                const offsetAngle = (Math.random() - 0.5) * 0.3;
                const extraShuriken = new Shuriken(x, y, angle + offsetAngle);
                gameState.shurikens.push(extraShuriken);
            }
        }

        let throwShuriken = originalThrowShuriken;

        function gameLoop(timestamp) {
            if (!gameState.lastTime) gameState.lastTime = timestamp;
            const deltaTime = timestamp - gameState.lastTime;
            gameState.lastTime = timestamp;
            
            if (gameState.gameOver) {
                showGameOver();
                return;
            }
            
            updateGame(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }

        function updateGame(deltaTime) {
            gameState.player.update(deltaTime);
            
            // Aumento de dano a cada 5 níveis
            if (gameState.level % 5 === 0 && gameState.damageMultiplier < 1 + (Math.floor(gameState.level / 5) * 0.2)) {
                gameState.damageMultiplier = 1 + (Math.floor(gameState.level / 5) * 0.2);
                Shuriken.prototype.damage = 11 * gameState.damageMultiplier;
            }
            
            // Meditação - cura quando parado
            if (gameState.healthRegen && gameState.isStandingStill) {
                const now = Date.now();
                if (now - gameState.lastMeditationHeal >= 2000) {
                    gameState.player.health = Math.min(
                        gameState.player.maxHealth,
                        gameState.player.health + gameState.player.maxHealth * 0.1
                    );
                    createParticles(gameState.player.x, gameState.player.y, 10, '#ff0');
                    gameState.lastMeditationHeal = now;
                }
            }
            
            // Mestre do Desespero - mais rápido com vida baixa
            if (gameState.timeSlow) {
                if (gameState.player.health <= gameState.player.maxHealth * 0.35) {
                    gameState.player.speed = gameState.player.originalSpeed * 1.5;
                } else {
                    gameState.player.speed = gameState.player.originalSpeed;
                }
            }
            
            // Último Esforço - mais dano com vida baixa
            if (gameState.finalGambit) {
                if (gameState.player.health <= gameState.player.maxHealth * 0.35) {
                    Shuriken.prototype.damage = 11 * gameState.damageMultiplier * 2;
                } else {
                    Shuriken.prototype.damage = 11 * gameState.damageMultiplier;
                }
            }
            
            gameState.shurikenTimer += deltaTime;
            if (gameState.mouse.isDown && gameState.shurikenTimer >= config.shurikenCooldown) {
                throwShuriken(
                    gameState.player.x,
                    gameState.player.y,
                    Math.atan2(
                        gameState.mouse.y - gameState.player.y,
                        gameState.mouse.x - gameState.player.x
                    )
                );
                gameState.shurikenTimer = 0;
            }
            
            for (let i = gameState.shurikens.length - 1; i >= 0; i--) {
                const shuriken = gameState.shurikens[i];
                shuriken.update(deltaTime);
                
                if (shuriken instanceof FireBreathProjectile) {
                    const dx = shuriken.x - gameState.player.x;
                    const dy = shuriken.y - gameState.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < shuriken.radius + gameState.player.radius) {
                        gameState.player.takeDamage(shuriken.damage);
                        gameState.player.applyBurn(5, 2000);
                        gameState.shurikens.splice(i, 1);
                        createParticles(shuriken.x, shuriken.y, 10, '#f80');
                        continue;
                    }
                }
                
                if (shuriken instanceof DarkMatterProjectile) {
                    const dx = shuriken.x - gameState.player.x;
                    const dy = shuriken.y - gameState.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Apenas colide com o jogador
                    if (dist < shuriken.radius + gameState.player.radius) {
                        gameState.player.takeDamage(shuriken.damage);
                        gameState.player.applySlow(0.3, 3000);
                        gameState.shurikens.splice(i, 1);
                        createParticles(shuriken.x, shuriken.y, 10, '#8e44ad');
                        continue;
                    }
                }
                
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dx = shuriken.x - enemy.x;
                    const dy = shuriken.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < shuriken.radius + enemy.radius) {
                        const died = enemy.takeDamage(shuriken.damage);
                        
                        createParticles(
                            enemy.x,
                            enemy.y,
                            5,
                            enemy.color
                        );
                        
                        if (shuriken.explosive) {
                            createExplosion(shuriken.x, shuriken.y, 50, shuriken.damage * 0.8);
                        }
                        
                        if (shuriken.atomic && died) {
                            createExplosion(enemy.x, enemy.y, 80, shuriken.damage * 0.5);
                        }
                        
                        if (died) {
                            gameState.score += enemy.xpValue;
                            gameState.xp += enemy.xpValue;
                            
                            createParticles(
                                enemy.x,
                                enemy.y,
                                15,
                                enemy.color
                            );
                            
                            if (gameState.shadowStep && Math.random() < 0.3) {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = 100;
                                gameState.player.x += Math.cos(angle) * distance;
                                gameState.player.y += Math.sin(angle) * distance;
                                createParticles(enemy.x, enemy.y, 20, '#888');
                            }
                            
                            if (gameState.bloodlust) {
                                gameState.player.health = Math.min(
                                    gameState.player.maxHealth,
                                    gameState.player.health + gameState.player.maxHealth * 0.08
                                );
                            }
                            
                            if (gameState.toxicCloud) {
                                const cloud = new ToxicCloud(enemy.x, enemy.y);
                                gameState.particles.push(cloud);
                            }
                            
                            gameState.enemies.splice(j, 1);
                            gameState.explosionHitboxes = gameState.explosionHitboxes.filter(
                                h => h !== enemy.explosionHitbox
                            );
                        }
                        
                        if (!shuriken.piercing && !shuriken.pinkPiercing) {
                            gameState.shurikens.splice(i, 1);
                            break;
                        }
                    }
                }
                
                for (let j = gameState.bosses.length - 1; j >= 0; j--) {
                    const boss = gameState.bosses[j];
                    const dx = shuriken.x - boss.x;
                    const dy = shuriken.y - boss.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < shuriken.radius + boss.radius) {
                        const died = boss.takeDamage(shuriken.damage);
                        
                        createParticles(
                            boss.x,
                            boss.y,
                            10,
                            boss.color
                        );
                        
                        if (died) {
                            createParticles(
                                boss.x,
                                boss.y,
                                30,
                                boss.color
                            );
                            gameState.bosses.splice(j, 1);
                            gameState.explosionHitboxes = gameState.explosionHitboxes.filter(
                                h => h !== boss.explosionHitbox
                            );
                        }
                        
                        if (!shuriken.piercing && !shuriken.pinkPiercing) {
                            gameState.shurikens.splice(i, 1);
                        }
                        
                        break;
                    }
                }
                
                if (gameState.shurikens[i] && gameState.shurikens[i].lifetime <= 0) {
                    gameState.shurikens.splice(i, 1);
                }
            }
            
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                enemy.update(deltaTime);
                
                if (enemy.burn) {
                    enemy.burn.timer += deltaTime;
                    if (enemy.burn.timer >= 700) {
                        const damageTaken = enemy.takeDamage(enemy.burn.damage);
                        enemy.burn.timer = 0;
                        createParticles(enemy.x, enemy.y, 2, '#f80');
                    }
                    if (enemy.burn.timer >= enemy.burn.duration) {
                        enemy.burn = null;
                        enemy.color = enemy.type === 'weak' ? '#f88' : 
                                     enemy.type === 'medium' ? '#f55' : 
                                     enemy.type === 'strong' ? '#f00' : '#c00';
                    }
                }
                
                if (enemy.lifetime !== undefined) {
                    enemy.lifetime -= deltaTime;
                    if (enemy.lifetime <= 0) {
                        gameState.enemies.splice(i, 1);
                        gameState.explosionHitboxes = gameState.explosionHitboxes.filter(
                            h => h !== enemy.explosionHitbox
                        );
                    }
                }
            }
            
            for (let i = gameState.bosses.length - 1; i >= 0; i--) {
                const boss = gameState.bosses[i];
                boss.update(deltaTime);
            }
            
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                
                if (particle instanceof ToxicCloud || particle instanceof DarkMatterPool) {
                    particle.update(deltaTime);
                    if (particle.lifetime <= 0) {
                        gameState.particles.splice(i, 1);
                    }
                } else {
                    particle.update(deltaTime);
                    if (particle.lifetime <= 0) {
                        gameState.particles.splice(i, 1);
                    }
                }
            }
            
            gameState.spawnTimer += deltaTime;
            const spawnRate = Math.max(500, config.enemySpawnRate - gameState.wave * 50);
            
            if (gameState.spawnTimer >= spawnRate && !gameState.bossActive && !gameState.omegaBossActive) {
                spawnEnemy();
                gameState.spawnTimer = 0;
            }
            
            gameState.waveTimer += deltaTime;
            if (gameState.waveTimer >= config.waveDuration) {
                nextWave();
            }
            
            if (!gameState.bossActive && !gameState.bossSpawned && gameState.wave % 5 === 0 && gameState.wave < 20) {
                spawnBoss();
                gameState.bossSpawned = true;
            }
            
            if (gameState.wave === 20 && !gameState.omegaBossActive && !gameState.bossSpawned) {
                spawnOmegaBoss();
                gameState.bossSpawned = true;
                gameState.omegaBossActive = true;
            }
            
            if (gameState.xp >= gameState.xpToLevel && gameState.level < 11) {
                showPowerUpSelection();
            }
            
            updateUI();
        }

        function spawnEnemy() {
            let type = 'weak';
            const rand = Math.random();
            const waveMod = Math.min(10, Math.floor(gameState.wave / 3));
            
            if (gameState.wave >= 15 && rand < 0.1) {
                type = 'thunder';
            } else if (gameState.wave >= 11 && rand < 0.2) {
                type = 'assassin';
            } else if (gameState.wave >= 9 && rand < 0.3) {
                type = 'tank';
            } else if (gameState.wave >= 7 && rand < 0.2) {
                type = 'elite';
            } else if (gameState.wave >= 4 && rand < 0.4) {
                type = 'strong';
            } else if (gameState.wave >= 2 && rand < 0.6) {
                type = 'medium';
            }
            
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            switch(side) {
                case 0:
                    x = Math.random() * gameState.canvas.width;
                    y = -20;
                    break;
                case 1:
                    x = gameState.canvas.width + 20;
                    y = Math.random() * gameState.canvas.height;
                    break;
                case 2:
                    x = Math.random() * gameState.canvas.width;
                    y = gameState.canvas.height + 20;
                    break;
                case 3:
                    x = -20;
                    y = Math.random() * gameState.canvas.height;
                    break;
            }
            
            const enemy = new Enemy(x, y, type);
            gameState.enemies.push(enemy);
        }

        function spawnBoss() {
            gameState.bossActive = true;
            
            const bossTypes = ['dragon', 'oni', 'shadow', 'thunder'];
            const randomType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
            
            const boss = new Boss(randomType);
            gameState.bosses.push(boss);
            
            document.getElementById('boss-health').style.display = 'block';
            document.getElementById('boss-name').textContent = boss.name;
        }

        function spawnOmegaBoss() {
            gameState.bossActive = true;
            
            const boss = new OmegaBoss();
            gameState.bosses.push(boss);
            
            document.getElementById('boss-health').style.display = 'block';
            document.getElementById('boss-name').textContent = boss.name;
        }

        function nextWave() {
            gameState.wave++;
            gameState.waveTimer = 0;
            gameState.bossSpawned = false;
            
            config.enemySpawnRate = Math.max(500, config.enemySpawnRate - 50);
        }

        function createParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3;
                
                gameState.particles.push(new Particle(
                    x,
                    y,
                    color,
                    Math.random() * 3 + 1,
                    {
                        x: Math.cos(angle) * speed,
                        y: Math.sin(angle) * speed
                    },
                    Math.random() * 1000 + 500
                ));
            }
        }

        function createExplosion(x, y, radius, damage) {
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5;
                
                gameState.particles.push(new Particle(
                    x,
                    y,
                    '#f80',
                    Math.random() * 5 + 2,
                    {
                        x: Math.cos(angle) * speed,
                        y: Math.sin(angle) * speed
                    },
                    Math.random() * 1000 + 500
                ));
            }
            
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                const dx = enemy.x - x;
                const dy = enemy.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < radius) {
                    const died = enemy.takeDamage(damage * (1 - dist / radius));
                    if (died) {
                        gameState.score += enemy.xpValue;
                        gameState.xp += enemy.xpValue;
                        gameState.enemies.splice(i, 1);
                        gameState.explosionHitboxes = gameState.explosionHitboxes.filter(
                            h => h !== enemy.explosionHitbox
                        );
                    }
                }
            }
            
            for (let i = gameState.bosses.length - 1; i >= 0; i--) {
                const boss = gameState.bosses[i];
                const dx = boss.x - x;
                const dy = boss.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < radius) {
                    const died = boss.takeDamage(damage * (1 - dist / radius));
                    if (died) {
                        gameState.bosses.splice(i, 1);
                        gameState.explosionHitboxes = gameState.explosionHitboxes.filter(
                            h => h !== boss.explosionHitbox
                        );
                    }
                }
            }
        }

        function createLightning(x1, y1, x2, y2) {
            const segments = 10;
            const points = [];
            
            points.push({ x: x1, y: y1 });
            
            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                const x = x1 + (x2 - x1) * t + (Math.random() - 0.5) * 30;
                const y = y1 + (y2 - y1) * t + (Math.random() - 0.5) * 30;
                points.push({ x, y });
            }
            
            points.push({ x: x2, y: y2 });
            
            gameState.ctx.save();
            gameState.ctx.beginPath();
            gameState.ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                gameState.ctx.lineTo(points[i].x, points[i].y);
            }
            
            gameState.ctx.strokeStyle = '#0ff';
            gameState.ctx.lineWidth = 2;
            gameState.ctx.stroke();
            gameState.ctx.restore();
            
            for (let i = 0; i < 10; i++) {
                const t = Math.random();
                const x = x1 + (x2 - x1) * t;
                const y = y1 + (y2 - y1) * t;
                
                gameState.particles.push(new Particle(
                    x,
                    y,
                    '#0ff',
                    Math.random() * 2 + 1,
                    {
                        x: (Math.random() - 0.5) * 3,
                        y: (Math.random() - 0.5) * 3
                    },
                    Math.random() * 500 + 200
                ));
            }
        }

        function showPowerUpSelection() {
            gameState.gamePaused = true;
            
            const levelPowerups = powerupsByLevel[gameState.level];
            gameState.currentPowerups = levelPowerups;
            
            const buttonsContainer = document.getElementById('powerup-buttons');
            buttonsContainer.style.display = 'flex';
            
            const optionsContainer = document.getElementById('powerup-options');
            optionsContainer.innerHTML = '';
            
            levelPowerups.forEach((powerup, index) => {
                const option = document.createElement('div');
                option.className = 'powerup-option';
                option.innerHTML = `<strong>${index+1}: ${powerup.name}</strong><br>${powerup.description}`;
                optionsContainer.appendChild(option);
            });
            
            document.getElementById('powerups').style.display = 'block';
        }

        function selectPowerUpByIndex(index) {
            if (index < 0 || index >= gameState.currentPowerups.length) return;
            
            const powerup = gameState.currentPowerups[index];
            powerup.apply();
            gameState.activePowerups.push(powerup);
            
            gameState.level++;
            gameState.xp -= gameState.xpToLevel;
            
            if (gameState.level <= 11) {
                gameState.xpToLevel = config.xpRequirements[gameState.level - 1];
            } else {
                gameState.xpToLevel = Infinity;
            }
            
            document.getElementById('powerups').style.display = 'none';
            document.getElementById('powerup-buttons').style.display = 'none';
            gameState.gamePaused = false;
            gameState.currentPowerups = [];
            
            updateUI();
        }

        function updateUI() {
            const healthPercent = gameState.player.health / gameState.player.maxHealth;
            document.getElementById('health-fill').style.width = `${healthPercent * 100}%`;
            
            const xpPercent = Math.min(100, (gameState.xp / gameState.xpToLevel) * 100);
            document.getElementById('xp-fill').style.width = `${xpPercent}%`;
            
            document.getElementById('wave-info').textContent = `Onda: ${gameState.wave}`;
            document.getElementById('score').textContent = `Pontuação: ${gameState.score}`;
            document.getElementById('level').textContent = `Nível: ${gameState.level}`;
            
            if (gameState.bosses.length > 0) {
                const boss = gameState.bosses[0];
                const bossHealthPercent = boss.health / boss.maxHealth;
                document.getElementById('boss-health-fill').style.width = `${bossHealthPercent * 100}%`;
            }
        }

        function showGameOver() {
            document.getElementById('final-score').textContent = `Pontuação: ${gameState.score}`;
            document.getElementById('final-wave').textContent = `Onda: ${gameState.wave}`;
            document.getElementById('final-level').textContent = `Nível: ${gameState.level}`;
            document.getElementById('game-over').style.display = 'block';
        }

        function render() {
            gameState.ctx.clearRect(0, 0, gameState.canvas.width, gameState.canvas.height);
            
            gameState.ctx.fillStyle = '#111';
            gameState.ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
            
            gameState.ctx.strokeStyle = '#222';
            gameState.ctx.lineWidth = 1;
            const gridSize = 50;
            
            for (let x = 0; x < gameState.canvas.width; x += gridSize) {
                gameState.ctx.beginPath();
                gameState.ctx.moveTo(x, 0);
                gameState.ctx.lineTo(x, gameState.canvas.height);
                gameState.ctx.stroke();
            }
            
            for (let y = 0; y < gameState.canvas.height; y += gridSize) {
                gameState.ctx.beginPath();
                gameState.ctx.moveTo(0, y);
                gameState.ctx.lineTo(gameState.canvas.width, y);
                gameState.ctx.stroke();
            }
            
            gameState.particles.forEach(p => {
                if (p instanceof ToxicCloud || p instanceof DarkMatterPool) {
                    p.draw(gameState.ctx);
                } else {
                    p.draw(gameState.ctx);
                }
            });
            
            gameState.enemies.forEach(e => e.draw(gameState.ctx));
            gameState.bosses.forEach(b => b.draw(gameState.ctx));
            gameState.shurikens.forEach(s => s.draw(gameState.ctx));
            gameState.player.draw(gameState.ctx);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
